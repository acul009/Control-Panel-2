// Code generated by goa v3.8.5, DO NOT EDIT.
//
// deployments HTTP server types
//
// Command:
// $ goa gen github.com/acul009/control-mono/api/deployments/design

package server

import (
	"unicode/utf8"

	deployments "github.com/acul009/control-mono/api/deployments/gen/deployments"
	goa "goa.design/goa/v3/pkg"
)

// UpsertRequestBody is the type of the "deployments" service "upsert" endpoint
// HTTP request body.
type UpsertRequestBody struct {
	Name       *string                 `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Containers []*ContainerRequestBody `form:"containers,omitempty" json:"containers,omitempty" xml:"containers,omitempty"`
	Params     []*ParameterRequestBody `form:"params,omitempty" json:"params,omitempty" xml:"params,omitempty"`
}

// GetResponseBody is the type of the "deployments" service "get" endpoint HTTP
// response body.
type GetResponseBody struct {
	Name       string                   `form:"name" json:"name" xml:"name"`
	Containers []*ContainerResponseBody `form:"containers" json:"containers" xml:"containers"`
	Params     []*ParameterResponseBody `form:"params,omitempty" json:"params,omitempty" xml:"params,omitempty"`
}

// GetDeploymentNotFoundResponseBody is the type of the "deployments" service
// "get" endpoint HTTP response body for the "DeploymentNotFound" error.
type GetDeploymentNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// DeleteDeploymentNotFoundResponseBody is the type of the "deployments"
// service "delete" endpoint HTTP response body for the "DeploymentNotFound"
// error.
type DeleteDeploymentNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ContainerResponseBody is used to define fields on response body types.
type ContainerResponseBody struct {
	Name       string                        `form:"name" json:"name" xml:"name"`
	Image      string                        `form:"image" json:"image" xml:"image"`
	UsedParams []*ParameterUsageResponseBody `form:"usedParams,omitempty" json:"usedParams,omitempty" xml:"usedParams,omitempty"`
	Services   []string                      `form:"services,omitempty" json:"services,omitempty" xml:"services,omitempty"`
}

// ParameterUsageResponseBody is used to define fields on response body types.
type ParameterUsageResponseBody struct {
	Name        *string  `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Environment []string `form:"environment,omitempty" json:"environment,omitempty" xml:"environment,omitempty"`
	Files       []string `form:"files,omitempty" json:"files,omitempty" xml:"files,omitempty"`
}

// ParameterResponseBody is used to define fields on response body types.
type ParameterResponseBody struct {
	Name   string `form:"name" json:"name" xml:"name"`
	Source string `form:"source" json:"source" xml:"source"`
	Type   string `form:"type" json:"type" xml:"type"`
}

// ContainerRequestBody is used to define fields on request body types.
type ContainerRequestBody struct {
	Name       *string                      `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Image      *string                      `form:"image,omitempty" json:"image,omitempty" xml:"image,omitempty"`
	UsedParams []*ParameterUsageRequestBody `form:"usedParams,omitempty" json:"usedParams,omitempty" xml:"usedParams,omitempty"`
	Services   []string                     `form:"services,omitempty" json:"services,omitempty" xml:"services,omitempty"`
}

// ParameterUsageRequestBody is used to define fields on request body types.
type ParameterUsageRequestBody struct {
	Name        *string  `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Environment []string `form:"environment,omitempty" json:"environment,omitempty" xml:"environment,omitempty"`
	Files       []string `form:"files,omitempty" json:"files,omitempty" xml:"files,omitempty"`
}

// ParameterRequestBody is used to define fields on request body types.
type ParameterRequestBody struct {
	Name   *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Source *string `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	Type   *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// NewGetResponseBody builds the HTTP response body from the result of the
// "get" endpoint of the "deployments" service.
func NewGetResponseBody(res *deployments.Deployment) *GetResponseBody {
	body := &GetResponseBody{
		Name: res.Name,
	}
	if res.Containers != nil {
		body.Containers = make([]*ContainerResponseBody, len(res.Containers))
		for i, val := range res.Containers {
			body.Containers[i] = marshalDeploymentsContainerToContainerResponseBody(val)
		}
	}
	if res.Params != nil {
		body.Params = make([]*ParameterResponseBody, len(res.Params))
		for i, val := range res.Params {
			body.Params[i] = marshalDeploymentsParameterToParameterResponseBody(val)
		}
	}
	return body
}

// NewGetDeploymentNotFoundResponseBody builds the HTTP response body from the
// result of the "get" endpoint of the "deployments" service.
func NewGetDeploymentNotFoundResponseBody(res *goa.ServiceError) *GetDeploymentNotFoundResponseBody {
	body := &GetDeploymentNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewDeleteDeploymentNotFoundResponseBody builds the HTTP response body from
// the result of the "delete" endpoint of the "deployments" service.
func NewDeleteDeploymentNotFoundResponseBody(res *goa.ServiceError) *DeleteDeploymentNotFoundResponseBody {
	body := &DeleteDeploymentNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewUpsertDeployment builds a deployments service upsert endpoint payload.
func NewUpsertDeployment(body *UpsertRequestBody) *deployments.Deployment {
	v := &deployments.Deployment{
		Name: *body.Name,
	}
	v.Containers = make([]*deployments.Container, len(body.Containers))
	for i, val := range body.Containers {
		v.Containers[i] = unmarshalContainerRequestBodyToDeploymentsContainer(val)
	}
	if body.Params != nil {
		v.Params = make([]*deployments.Parameter, len(body.Params))
		for i, val := range body.Params {
			v.Params[i] = unmarshalParameterRequestBodyToDeploymentsParameter(val)
		}
	}

	return v
}

// ValidateUpsertRequestBody runs the validations defined on UpsertRequestBody
func ValidateUpsertRequestBody(body *UpsertRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Containers == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("containers", "body"))
	}
	if len(body.Containers) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.containers", body.Containers, len(body.Containers), 1, true))
	}
	for _, e := range body.Containers {
		if e != nil {
			if err2 := ValidateContainerRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Params {
		if e != nil {
			if err2 := ValidateParameterRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateContainerRequestBody runs the validations defined on
// ContainerRequestBody
func ValidateContainerRequestBody(body *ContainerRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Image == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("image", "body"))
	}
	for _, e := range body.UsedParams {
		if e != nil {
			if err2 := ValidateParameterUsageRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateParameterUsageRequestBody runs the validations defined on
// ParameterUsageRequestBody
func ValidateParameterUsageRequestBody(body *ParameterUsageRequestBody) (err error) {
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 1, true))
		}
	}
	return
}

// ValidateParameterRequestBody runs the validations defined on
// ParameterRequestBody
func ValidateParameterRequestBody(body *ParameterRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Source == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("source", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 1, true))
		}
	}
	if body.Source != nil {
		if !(*body.Source == "static" || *body.Source == "generated" || *body.Source == "configurable") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.source", *body.Source, []interface{}{"static", "generated", "configurable"}))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "string" || *body.Type == "int" || *body.Type == "bool" || *body.Type == "password") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []interface{}{"string", "int", "bool", "password"}))
		}
	}
	return
}
